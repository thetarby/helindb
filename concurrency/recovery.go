package concurrency

import (
	"helin/disk/wal"
	"helin/transaction"
)

type Recovery struct {
	logs       wal.LogIterator
	txnManager TxnManager
	logManager wal.LogManager
}

func (r *Recovery) Recover() error {
	if err := wal.PrevToType(r.logs, wal.TypeCheckpointEnd); err != nil {
		return err
	}

	if err := wal.PrevToType(r.logs, wal.TypeCheckpointBegin); err != nil {
		return err
	}

	// TODO: Somehow get active txn from checkpoint begin
	activeTxn := make(map[transaction.TxnID]bool)

	// redo all logs until log end and populate active txn map
	for {
		lr, err := r.logs.Next()
		if err != nil {
			return err
		}
		if lr == nil {
			break
		}

		txn := lr.GetTxnID()
		if lr.Type() == wal.TypeCommit {
			delete(activeTxn, txn)
		} else {
			activeTxn[txn] = true
		}

		if err := r.Redo(lr); err != nil {
			return err
		}
	}

	// Abort all active transactions that are running when crash occurred.
	// This essentially will undo all logs generated by these transactions.
	for id := range activeTxn {
		r.txnManager.AbortByID(id)
	}

	return nil
}

// Rollback undoes all the changes on pages reflected by given log records using buffer pool.
func (r *Recovery) Rollback(txnID transaction.TxnID, lr []*wal.LogRecord) error {
	for _, record := range lr {
		if err := r.Undo(record); err != nil {
			return err
		}
	}

	r.logManager.AppendLog(wal.NewAbortLogRecord(txnID))
	return nil
}

// Redo applies change in the log record if page's pageLsn is smaller than log's lsn, if not, this is a noop since
// changes are already on the page.
func (r *Recovery) Redo(lr *wal.LogRecord) error {
	panic("implement me")
}

// Undo creates a clr entry for given log and undoes it.
func (r *Recovery) Undo(lr *wal.LogRecord) error {
	// 1. create clr
	// 2. append clr to wal
	// 3. fetch page from buffer pool and cast it to slotted page
	// 4. undo action taken by log
	panic("implement me")
}
