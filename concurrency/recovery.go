package concurrency

import (
	"bytes"
	"errors"
	"fmt"
	"helin/common"
	"helin/disk/pages"
	"helin/disk/wal"
	"helin/transaction"
	"io"
	"log"
	"os"
)

type DiskManager interface {
	GetPage(pageId uint64) (*pages.SlottedPage, error)
	IsInFreeList(pageID uint64) (bool, error)
	FreePage(pageID uint64)
	RemoveFromFreelist(pageID uint64) error
}

// Recovery encapsulates logic about coming back from a crash. It brings database file to its latest stable state.
type Recovery struct {
	logs       wal.LogIterator
	logManager *wal.LogManager
	dm         DiskManager
}

func NewRecovery(logFile *os.File, logSer wal.LogRecordSerializer, dm DiskManager) (*Recovery, error) {
	iter, err := wal.NewLogIter(logFile, logSer, 0)
	if err != nil {
		return nil, err
	}

	return &Recovery{
		logs:       iter,
		logManager: wal.NewLogManager(logFile),
		dm:         dm,
	}, nil
}

// Recover is called to come back from failures. Brings database file to its latest correct state.
func (r *Recovery) Recover() error {
	// 1. iterate over logs and locate the latest successful checkpoint's begin record
	// 2. redo all log records until the end of iterator to bring database file to the state when crash occurred
	// 3. populate active transactions by keeping track of commit, abort and begin log records
	// 4. rollback all transactions in active transactions list
	if err := wal.PrevToType(r.logs, wal.TypeCheckpointEnd); err != nil {
		return err
	}

	if err := wal.PrevToType(r.logs, wal.TypeCheckpointBegin); err != nil {
		return err
	}

	// get active transactions
	activeTxn := make(map[transaction.TxnID]bool)
	lr, err := r.logs.Curr()
	if err != nil {
		return err
	}

	for _, active := range lr.Actives {
		activeTxn[active] = true
	}

	// redo all logs until log end and populate active txn map
	for {
		lr, err := r.logs.Next()
		if err != nil {
			if err == wal.ErrIteratorAtLast {
				break
			}

			return fmt.Errorf("next failed: %w", err)
		}

		if common.OneOf(lr.Type(), wal.TypeCheckpointEnd, wal.TypeCheckpointBegin) {
			continue
		}

		txn := lr.GetTxnID()
		if lr.Type() == wal.TypeCommit {
			delete(activeTxn, txn)
			continue
		} else {
			activeTxn[txn] = true
		}

		if err := r.Redo(lr); err != nil {
			return fmt.Errorf("redo error %w", err)
		}
	}

	log.Println("these transactions will be rolled back:")
	for id := range activeTxn {
		log.Printf("rolling back txn: %v\n", id)
	}

	// Abort all active transactions that are running when crash occurred.
	// This essentially will undo all logs generated by these transactions.
	for id := range activeTxn {
		r.RollbackTxn(id)
	}

	return nil
}

// RollbackTxn rolls back all the changes reflected by transaction's log records.
func (r *Recovery) RollbackTxn(id transaction.TxnID) {
	// 1. create an iterator on logs that will iterate a transaction's logs in reverse order
	// 2. create clr logs that are basically logical negations of corresponding logs
	// 3. apply clr records and append them to wal
	// 4. append abort log

	logs := wal.NewTxnLogIterator(id, r.logs)
	for {
		lr, err := logs.Prev()
		if err != nil {
			if errors.Is(err, wal.ErrIteratorAtBeginning) {
				break
			}
		}

		if lr == nil {
			// if logs are finished it is rolled back
			break
		}

		if err := r.Undo(lr); err != nil {
			panic(err)
		}
	}

	r.logManager.AppendLog(wal.NewAbortLogRecord(id))
}

// Redo applies change in the log record if page's pageLsn is smaller than log's lsn and updates pageLsn,
// if not, this is a noop since changes are already on the page.
func (r *Recovery) Redo(lr *wal.LogRecord) error {
	// TODO: HANDLE CLR RECORDS
	p, err := r.dm.GetPage(lr.PageID)
	if err != nil {
		return err
	}

	if p.GetPageLSN() >= lr.Lsn {
		return nil
	}
	if p.GetPageLSN() == 0 {
		p.SetPageLSN(lr.Lsn)
	}

	// first redo changes
	switch lr.Type() {
	case wal.TypeInsert:
		if err := p.InsertAt(int(lr.Idx), lr.Payload); err != nil {
			return err
		}
	case wal.TypeDelete:
		// TODO: validate if deleted is the same
		if d := p.GetAt(int(lr.Idx)); bytes.Compare(d, lr.OldPayload) != 0 {
			return errors.New("payload is different than logged")
		}

		if err := p.DeleteAt(int(lr.Idx)); err != nil {
			return err
		}
	case wal.TypeSet:
		if d := p.GetAt(int(lr.Idx)); bytes.Compare(d, lr.OldPayload) != 0 {
			return errors.New("payload is different than logged")
		}

		if err := p.SetAt(int(lr.Idx), lr.Payload); err != nil {
			return err
		}
	case wal.TypeFreePage:
		if ok, err := r.dm.IsInFreeList(lr.PageID); err != nil {
			return err
		} else if !ok {
			r.dm.FreePage(lr.PageID)
		}
	case wal.TypeNewPage:
		if ok, err := r.dm.IsInFreeList(lr.PageID); err != nil {
			return err
		} else if ok {
			if err := r.dm.RemoveFromFreelist(lr.PageID); err != nil {
				return err
			}
		}
	default:
		panic("implement me")
	}

	// then update page lsn
	p.SetPageLSN(lr.Lsn)
	p.SetDirty()

	return nil
}

// Undo appends a clr entry for given log and undoes it.
func (r *Recovery) Undo(lr *wal.LogRecord) error {
	// 1. create clr
	// 2. append clr to wal
	// 3. fetch page from buffer pool and cast it to slotted page
	// 4. undo action taken by log
	// TODO: when rolling back free page if a page with different id is created, btree nodes may point to the old page id
	p, err := r.dm.GetPage(lr.PageID)
	if err != nil {
		if err == io.EOF {
			sp := pages.InitSlottedPage(pages.NewRawPage(lr.PageID))
			p = &sp
		} else {
			return err
		}
	}

	if p.GetPageLSN() < lr.Lsn {
		panic("corrupted redo phase")
	}

	r.logManager.AppendLog(lr.Clr()) // TODO: should we wait for flush?

	switch lr.Type() {
	case wal.TypeDelete:
		common.PanicIfErr(p.InsertAt(int(lr.Idx), lr.OldPayload))
	case wal.TypeSet:
		d := p.GetAt(int(lr.Idx))
		if bytes.Compare(d, lr.Payload) != 0 {
			panic("payload is different than logged")
		}
		common.PanicIfErr(p.SetAt(int(lr.Idx), lr.OldPayload))
	case wal.TypeInsert:
		d := p.GetAt(int(lr.Idx))
		if bytes.Compare(d, lr.Payload) != 0 {
			panic("payload is different than logged")
		}
		common.PanicIfErr(p.DeleteAt(int(lr.Idx)))
	case wal.TypeNewPage:
		r.dm.FreePage(lr.PageID)
	case wal.TypeFreePage:
		common.PanicIfErr(r.dm.RemoveFromFreelist(lr.PageID))
	default:
		panic("implement me")
	}

	return nil
}
