package concurrency

import (
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	"helin/common"
	"helin/disk/pages"
	"helin/disk/wal"
	"helin/freelist"
	"helin/transaction"
	"io"
	"log"
)

type DiskManager interface {
	GetPage(pageId uint64) (*pages.SlottedPage, error)
	Unpin(pageId uint64)
	NewPage(pageId uint64) (*pages.SlottedPage, error)
	FreePage(txn transaction.TxnID, pageID uint64)
	FreePageInRecovery(txn transaction.TxnID, pageID uint64, undoNext pages.LSN)
	GetFreeListLsn() pages.LSN
}

// Recovery encapsulates logic about coming back from a crash. It brings database file to its latest stable state.
type Recovery struct {
	logs       wal.LogIterator
	logManager wal.LogManager
	dm         DiskManager
}

func NewRecovery(iter wal.LogIterator, lm wal.LogManager, dm DiskManager) (*Recovery, error) {
	return &Recovery{
		logs:       iter,
		logManager: lm,
		dm:         dm,
	}, nil
}

// Recover is called to come back from failures. Brings database file to its latest correct state.
func (r *Recovery) Recover() error {
	// 1. iterate over logs and locate the latest successful checkpoint's begin record
	// 2. redo all log records until the end of iterator to bring database file to the state when crash occurred
	// 3. populate active transactions by keeping track of commit, abort and begin log records
	// 4. rollback all transactions in active transactions list
	if err := wal.PrevToType(r.logs, wal.TypeCheckpointEnd); err != nil {
		return err
	}

	if err := wal.PrevToType(r.logs, wal.TypeCheckpointBegin); err != nil {
		return err
	}

	// get active transactions
	activeTxn := make(map[transaction.TxnID]string)
	lr, err := r.logs.Curr()
	if err != nil {
		return err
	}

	for _, active := range lr.Actives {
		activeTxn[active] = "undo"
	}

	// redo all logs until log end and populate active txn map
	for {
		lr, err := r.logs.Next()
		if err != nil {
			if err == wal.ErrIteratorAtLast {
				break
			}

			return fmt.Errorf("next failed: %w", err)
		}

		if common.OneOf(lr.Type(), wal.TypeCheckpointEnd, wal.TypeCheckpointBegin) {
			continue
		}

		txn := lr.GetTxnID()
		if lr.Type() == wal.TypeTxnEnd {
			delete(activeTxn, txn)
			continue
		} else if lr.Type() == wal.TypeCommit {
			activeTxn[txn] = "commit"
			continue
		} else {
			activeTxn[txn] = "undo"
		}

		if err := r.Redo(lr); err != nil {
			return fmt.Errorf("redo error %w", err)
		}
	}

	log.Println("active transactions during crash:")
	for id, status := range activeTxn {
		log.Printf("active txn: %v, status: %v\n", id, status)
	}

	// Complete all transactions that are active and committed.
	for id, status := range activeTxn {
		if status == "commit" {
			if err := r.CompleteTxn(id); err != nil {
				return fmt.Errorf("redo complete error %w", err)
			}
		}
	}

	// Abort all active transactions that are active and uncommitted when crash occurred.
	// This essentially will undo all logs generated by these transactions.
	for id, status := range activeTxn {
		if status == "undo" {
			r.RollbackTxn(id)
		}
	}

	return nil
}

// RollbackTxn rolls back all the changes reflected by transaction's log records.
func (r *Recovery) RollbackTxn(id transaction.TxnID) {
	// 1. create an iterator on logs that will iterate a transaction's logs in reverse order
	// 2. create clr logs that are basically logical negations of corresponding logs
	// 3. apply clr records and append them to wal
	// 4. append abort log

	logs := wal.NewTxnLogIterator(id, r.logs)
	for {
		lr, err := logs.Prev()
		if err != nil {
			if errors.Is(err, wal.ErrIteratorAtBeginning) {
				break
			}
		}

		if lr == nil {
			// if logs are finished it is rolled back
			break
		}

		common.Assert(lr.Type() != wal.TypeCommit, "rollback called on committed txn: %v", id)
		common.Assert(lr.Type() != wal.TypeFreePage, "free page cannot be undone txn: %v", id)
		common.Assert(lr.Type() != wal.TypeFreePageSet, "free page cannot be undone txn: %v", id)

		// TODO: undo next
		if err := r.Undo(lr, 0); err != nil {
			panic(err)
		}
	}

	r.logManager.AppendLog(wal.NewAbortLogRecord(id))
}

// CompleteTxn completes a committed transaction that has some incomplete pending actions
// (it only includes freeing pages for now).
func (r *Recovery) CompleteTxn(id transaction.TxnID) error {
	logs := wal.NewTxnLogIterator(id, r.logs)

	if err := wal.PrevToType(logs, wal.TypeCommit); err != nil {
		return err
	}

	lr, err := logs.Curr()
	if err != nil {
		return err
	}

	toFree := map[uint64]bool{}
	for _, page := range lr.FreedPages {
		toFree[page] = true
	}

	for {
		lr, err := logs.Next()
		if err != nil {
			if errors.Is(err, wal.ErrIteratorAtLast) {
				break
			}

			return err
		}

		// assertions
		common.Assert(lr.Type() == wal.TypeFreePage || lr.Type() == wal.TypeFreePageSet, "encountered a log record other than TypeFreePage after TypeCommit")
		common.Assert(toFree[lr.PageID], "txn freed a page that is not in FreedPages")

		// no need to do anything when TypeFreePageSet
		if lr.Type() == wal.TypeFreePage {
			// assertions
			common.Assert(toFree[lr.PageID], "txn freed a page that is not in FreedPages")
			common.Assert(r.dm.GetFreeListLsn() < lr.Lsn, "complete txn encountered a log record that is not redone")

			// delete pageID from toFree.
			delete(toFree, lr.PageID)
		}
	}

	// 3. for all remaining pages in toFree, free all pages and append corresponding TypeFreePage log records.
	for page := range toFree {
		r.dm.FreePage(id, page)
	}

	// 4. append end record and complete txn
	r.logManager.AppendLog(wal.NewTxnEndLogRecord(id))
	return nil
}

// Redo applies change in the log record if page's pageLsn is smaller than log's lsn and updates pageLsn,
// if not, this is a noop since changes are already on the page.
func (r *Recovery) Redo(lr *wal.LogRecord) error {
	if lr.Type() == wal.TypeNewPage && !lr.IsPop() {
		// if this is a new page which is not popped from free list, it might not make it to the disk yet, meaning
		// it would return EOF if one tries to read it from disk.
		p, err := r.dm.GetPage(lr.PageID)
		if err != nil {
			if err == io.EOF {
				p, err = r.dm.NewPage(lr.PageID)
				if err != nil {
					return err
				}

				p.SetDirty()
				r.dm.Unpin(lr.PageID)
				return nil
			}

			return err
		}
	}

	pageID := lr.PageID
	if lr.Type() == wal.TypeFreePage {
		// if it is a free page log record, page id represents freed page's id but, we want to modify free list
		// hence fetch free list header page.
		pageID = freelist.HeaderPageID
	}

	p, err := r.dm.GetPage(pageID)
	if err != nil {
		return err
	}
	defer r.dm.Unpin(lr.PageID)

	// NOTE: page is not formatted or initialized at all. this can happen when a page is not synced to file but a page with
	// larger pageID is synced. (seek operation writes zeros in between)
	if p.GetPageLSN() == 0 {
		sp := pages.InitSlottedPage(p)
		p = &sp
		p.SetDirty()
	}

	// note that if this is a TypeFreePage log record p.GetPageLSN() returns free list's lsn.
	if p.GetPageLSN() >= lr.Lsn {
		return nil
	}

	// first redo changes
	switch lr.Type() {
	case wal.TypeInsert:
		if err := p.InsertAt(int(lr.Idx), lr.Payload); err != nil {
			return err
		}
	case wal.TypeDelete:
		if d := p.GetAt(int(lr.Idx)); bytes.Compare(d, lr.OldPayload) != 0 {
			return fmt.Errorf("payload is different than logged: %v", base64.StdEncoding.EncodeToString(d))
		}

		if err := p.DeleteAt(int(lr.Idx)); err != nil {
			return err
		}
	case wal.TypeSet, wal.TypeFreePageSet:
		if d := p.GetAt(int(lr.Idx)); bytes.Compare(d, lr.OldPayload) != 0 {
			return errors.New("payload is different than logged")
		}

		if err := p.SetAt(int(lr.Idx), lr.Payload); err != nil {
			return err
		}
	case wal.TypeFreePage:
		if d := p.GetAt(int(lr.Idx)); bytes.Compare(d, lr.OldPayload) != 0 {
			return errors.New("payload is different than logged")
		}

		if err := p.SetAt(int(lr.Idx), lr.Payload); err != nil {
			return err
		}
	case wal.TypeNewPage:
		if d := p.GetAt(int(lr.Idx)); bytes.Compare(d, lr.OldPayload) != 0 {
			return errors.New("payload is different than logged")
		}

		if err := p.SetAt(int(lr.Idx), lr.Payload); err != nil {
			return err
		}
	default:
		panic("unknown log type")
	}

	// then update page lsn
	p.SetPageLSN(lr.Lsn)
	p.SetDirty()

	return nil
}

// Undo appends a clr entry for given log and undoes it. Note that undo is not a conditional operation unlike redo,
// meaning, there is no need to compare pageLsn etc. All log records are always undone unconditionally. This is
// because undo phase starts after redo phase completed and that means all log records are already known to be applied.
func (r *Recovery) Undo(lr *wal.LogRecord, undoNext pages.LSN) error {
	// 1. create clr
	// 2. append clr to wal
	// 3. fetch page from buffer pool and cast it to slotted page
	// 4. undo action taken by log

	if lr.Type() == wal.TypeCommit {
		return fmt.Errorf("undoing committed txn: %v", lr.TxnID)
	}

	if common.OneOf(lr.Type(), wal.TypeAbort, wal.TypeTxnBegin) {
		return nil
	}

	p, err := r.dm.GetPage(lr.PageID)
	if err != nil {
		return err
	}
	defer r.dm.Unpin(lr.PageID)

	if p.GetPageLSN() < lr.Lsn {
		panic("corrupted redo phase")
	}

	switch lr.Type() {
	case wal.TypeDelete:
		common.PanicIfErr(p.InsertAt(int(lr.Idx), lr.OldPayload))

		// append clr
		lr = wal.NewInsertLogRecord(lr.TxnID, lr.Idx, lr.Payload, p.GetPageId())
		lr.IsClr = true
		lr.UndoNext = undoNext
		lsn := r.logManager.AppendLog(lr)
		p.SetPageLSN(lsn)
	case wal.TypeSet:
		d := p.GetAt(int(lr.Idx))
		if bytes.Compare(d, lr.Payload) != 0 {
			return fmt.Errorf("payload is different than logged: %v", base64.StdEncoding.EncodeToString(d))
		}

		common.PanicIfErr(p.SetAt(int(lr.Idx), lr.OldPayload))

		// append clr
		lr = wal.NewSetLogRecord(lr.TxnID, lr.Idx, lr.OldPayload, d, lr.PageID)
		lr.IsClr = true
		lr.UndoNext = undoNext
		lsn := r.logManager.AppendLog(lr)
		p.SetPageLSN(lsn)
	case wal.TypeInsert:
		d := p.GetAt(int(lr.Idx))
		if bytes.Compare(d, lr.Payload) != 0 {
			panic("payload is different than logged")
		}

		common.PanicIfErr(p.DeleteAt(int(lr.Idx)))

		// append clr
		lr = wal.NewDeleteLogRecord(lr.TxnID, lr.Idx, d, lr.PageID)
		lr.IsClr = true
		lr.UndoNext = undoNext
		lsn := r.logManager.AppendLog(lr)
		p.SetPageLSN(lsn)
	case wal.TypeNewPage:
		r.dm.FreePageInRecovery(lr.TxnID, lr.PageID, undoNext)
	default:
		return fmt.Errorf("unrecognized log record type encountered for undo, type: %v", lr.Type())
	}

	return nil
}
