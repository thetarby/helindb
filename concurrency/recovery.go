package concurrency

import (
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	"helin/common"
	"helin/disk/pages"
	"helin/disk/wal"
	"helin/transaction"
	"io"
	"log"
	"os"
)

type DiskManager interface {
	GetPage(pageId uint64) (*pages.SlottedPage, error)
	Unpin(pageId uint64)
	NewPage(pageId uint64) (*pages.SlottedPage, error)
	FreePage(pageID uint64) error
	GetFreeListLsn() pages.LSN
}

// Recovery encapsulates logic about coming back from a crash. It brings database file to its latest stable state.
type Recovery struct {
	logs       wal.LogIterator
	logManager wal.LogManager
	dm         DiskManager
}

func NewRecovery(logFile *os.File, logSer wal.LogRecordSerializer, dm DiskManager) (*Recovery, error) {
	iter, err := wal.NewLogIter(logFile, logSer, 0)
	if err != nil {
		return nil, err
	}

	return &Recovery{
		logs:       iter,
		logManager: wal.NewLogManager(logFile),
		dm:         dm,
	}, nil
}

// Recover is called to come back from failures. Brings database file to its latest correct state.
func (r *Recovery) Recover() error {
	// 1. iterate over logs and locate the latest successful checkpoint's begin record
	// 2. redo all log records until the end of iterator to bring database file to the state when crash occurred
	// 3. populate active transactions by keeping track of commit, abort and begin log records
	// 4. rollback all transactions in active transactions list
	if err := wal.PrevToType(r.logs, wal.TypeCheckpointEnd); err != nil {
		return err
	}

	if err := wal.PrevToType(r.logs, wal.TypeCheckpointBegin); err != nil {
		return err
	}

	// get active transactions
	activeTxn := make(map[transaction.TxnID]string)
	lr, err := r.logs.Curr()
	if err != nil {
		return err
	}

	for _, active := range lr.Actives {
		activeTxn[active] = "undo"
	}

	// redo all logs until log end and populate active txn map
	for {
		lr, err := r.logs.Next()
		if err != nil {
			if err == wal.ErrIteratorAtLast {
				break
			}

			return fmt.Errorf("next failed: %w", err)
		}

		if common.OneOf(lr.Type(), wal.TypeCheckpointEnd, wal.TypeCheckpointBegin) {
			continue
		}

		txn := lr.GetTxnID()
		if lr.Type() == wal.TypeTxnEnd {
			delete(activeTxn, txn)
			continue
		} else if lr.Type() == wal.TypeCommit {
			activeTxn[txn] = "commit"
			continue
		} else {
			activeTxn[txn] = "undo"
		}

		if err := r.Redo(lr); err != nil {
			return fmt.Errorf("redo error %w", err)
		}
	}

	log.Println("these transactions will be rolled back:")
	for id, status := range activeTxn {
		log.Printf("active txn: %v, status: %v\n", id, status)
	}

	// Complete all transactions are active and committed.
	for id, status := range activeTxn {
		if status == "commit" {
			if err := r.CompleteTxn(id); err != nil {
				return fmt.Errorf("redo complete error %w", err)
			}
		}
	}

	// Abort all active transactions that are active and uncommitted when crash occurred.
	// This essentially will undo all logs generated by these transactions.
	for id, status := range activeTxn {
		if status == "undo" {
			r.RollbackTxn(id)
		}
	}

	return nil
}

// RollbackTxn rolls back all the changes reflected by transaction's log records.
func (r *Recovery) RollbackTxn(id transaction.TxnID) {
	// 1. create an iterator on logs that will iterate a transaction's logs in reverse order
	// 2. create clr logs that are basically logical negations of corresponding logs
	// 3. apply clr records and append them to wal
	// 4. append abort log

	logs := wal.NewTxnLogIterator(id, r.logs)
	for {
		lr, err := logs.Prev()
		if err != nil {
			if errors.Is(err, wal.ErrIteratorAtBeginning) {
				break
			}
		}

		if lr == nil {
			// if logs are finished it is rolled back
			break
		}

		common.Assert(lr.Type() != wal.TypeCommit, "rollback called on committed txn: %v", id)

		if err := r.Undo(lr); err != nil {
			panic(err)
		}
	}

	r.logManager.AppendLog(wal.NewAbortLogRecord(id))
}

// CompleteTxn completes a committed transaction that has some incomplete pending actions
// (it can only freeing pages for now).
func (r *Recovery) CompleteTxn(id transaction.TxnID) error {
	logs := wal.NewTxnLogIterator(id, r.logs)

	if err := wal.PrevToType(logs, wal.TypeCommit); err != nil {
		return err
	}

	lr, err := logs.Curr()
	if err != nil {
		return err
	}

	toFree := map[uint64]bool{}
	for _, page := range lr.FreedPages {
		toFree[page] = true
	}

	for {
		lr, err := logs.Next()
		if err != nil {
			if errors.Is(err, wal.ErrIteratorAtLast) {
				break
			}

			return err
		}

		// assertions
		common.Assert(lr.Type() == wal.TypeFreePage, "encountered a log record other than TypeFreePage after TypeCommit")
		common.Assert(toFree[lr.PageID], "txn freed a page that is not in FreedPages")

		// 1. compare freelist lsn with log's lsn and free page if log's lsn is larger.
		if r.dm.GetFreeListLsn() < lr.Lsn {
			if err := r.dm.FreePage(lr.PageID); err != nil {
				return fmt.Errorf("CompleteTxn error: %w", err)
			}
		}

		// 2. delete pageID from toFree.
		delete(toFree, lr.PageID)
	}

	// 3. for all remaining pages in toFree, free all pages and append corresponding TypeFreePage log records.
	for page := range toFree {
		r.logManager.AppendLog(wal.NewFreePageLogRecord(id, page))
		if err := r.dm.FreePage(page); err != nil {
			return fmt.Errorf("CompleteTxn error: %w", err)
		}
	}

	// 4. append end record and complete txn
	r.logManager.AppendLog(wal.NewTxnEndLogRecord(id))
	return nil
}

// Redo applies change in the log record if page's pageLsn is smaller than log's lsn and updates pageLsn,
// if not, this is a noop since changes are already on the page.
func (r *Recovery) Redo(lr *wal.LogRecord) error {
	// TODO: HANDLE CLR RECORDS
	p, err := r.dm.GetPage(lr.PageID)
	if err != nil {
		if err == io.EOF && lr.Type() == wal.TypeNewPage {
			p, err = r.dm.NewPage(lr.PageID)
			if err != nil {
				return err
			}

			p.SetPageLSN(lr.Lsn)
			p.SetDirty()
		} else {
			return err
		}
	}
	defer r.dm.Unpin(lr.PageID)

	// NOTE: page is not formatted or initialized at all. this can happen when a page is not synced to file but a page with
	// larger pageID is synced. (seek operation writes zeros in between)
	if p.GetPageLSN() == 0 {
		sp := pages.InitSlottedPage(p)
		p = &sp
		p.SetDirty()
	}

	if p.GetPageLSN() >= lr.Lsn {
		return nil
	}

	// first redo changes
	switch lr.Type() {
	case wal.TypeInsert:
		if err := p.InsertAt(int(lr.Idx), lr.Payload); err != nil {
			return err
		}
	case wal.TypeDelete:
		if d := p.GetAt(int(lr.Idx)); bytes.Compare(d, lr.OldPayload) != 0 {
			return fmt.Errorf("payload is different than logged: %v", base64.StdEncoding.EncodeToString(d))
		}

		if err := p.DeleteAt(int(lr.Idx)); err != nil {
			return err
		}
	case wal.TypeSet:
		if d := p.GetAt(int(lr.Idx)); bytes.Compare(d, lr.OldPayload) != 0 {
			return errors.New("payload is different than logged")
		}

		if err := p.SetAt(int(lr.Idx), lr.Payload); err != nil {
			return err
		}
	case wal.TypeNewPage:
		//if ok, err := r.dm.IsInFreeList(lr.PageID); err != nil {
		//	return err
		//} else if ok {
		//	if err := r.dm.RemoveFromFreelist(lr.PageID); err != nil {
		//		return err
		//	}
		//}
		// do nothing, handled above
	case wal.TypeFreePage:
		// handled in complete
	default:
		panic("implement me")
	}

	// then update page lsn
	p.SetPageLSN(lr.Lsn)
	p.SetDirty()

	return nil
}

// Undo appends a clr entry for given log and undoes it. Note that undo is not a conditional operation unlike redo,
// meaning, there is no need to compare pageLsn etc. All log records are always undone unconditionally. This is
// because undo phase starts after redo phase completed and that means all log records are already known to be applied.
func (r *Recovery) Undo(lr *wal.LogRecord) error {
	// 1. create clr
	// 2. append clr to wal
	// 3. fetch page from buffer pool and cast it to slotted page
	// 4. undo action taken by log

	// IMPORTANT NOTE: when rolling back free page if a page with different id is created, btree nodes may point to
	// the old page id.
	if lr.Type() == wal.TypeCommit {
		return fmt.Errorf("undoing committed txn: %v", lr.TxnID)
	}

	if common.OneOf(lr.Type(), wal.TypeAbort, wal.TypeTxnBegin) {
		return nil
	}

	p, err := r.dm.GetPage(lr.PageID)
	if err != nil {
		return err
	}
	defer r.dm.Unpin(lr.PageID)

	if p.GetPageLSN() < lr.Lsn {
		panic("corrupted redo phase")
	}

	r.logManager.AppendLog(lr.Clr()) // TODO: should we wait for flush?
	if lr.PageID == 4250 {
		println("asd")
	}
	switch lr.Type() {
	case wal.TypeDelete:
		common.PanicIfErr(p.InsertAt(int(lr.Idx), lr.OldPayload))
	case wal.TypeSet:
		d := p.GetAt(int(lr.Idx))
		if bytes.Compare(d, lr.Payload) != 0 {
			return fmt.Errorf("payload is different than logged: %v", base64.StdEncoding.EncodeToString(d))
		}
		common.PanicIfErr(p.SetAt(int(lr.Idx), lr.OldPayload))
	case wal.TypeInsert:
		d := p.GetAt(int(lr.Idx))
		if bytes.Compare(d, lr.Payload) != 0 {
			panic("payload is different than logged")
		}
		common.PanicIfErr(p.DeleteAt(int(lr.Idx)))
	case wal.TypeNewPage:
		common.PanicIfErr(r.dm.FreePage(lr.PageID))
	default:
		return fmt.Errorf("unrecognized log record type encountered for undo, type: %v", lr.Type())
	}

	return nil
}
