package concurrency

import (
	"bytes"
	"errors"
	"helin/common"
	"helin/disk/pages"
	"helin/disk/wal"
	"helin/transaction"
	"os"
)

type DiskManager interface {
	GetPage(pageId uint64) (*pages.SlottedPage, error)
	IsInFreeList(pageID uint64) (bool, error)
	FreePage(pageID uint64)
	RemoveFromFreelist(pageID uint64) error
}

type Recovery struct {
	logs       wal.LogIterator
	logManager *wal.LogManager
	dm         DiskManager
}

func NewRecovery(logFile *os.File, logSer wal.LogRecordSerializer, dm DiskManager) (*Recovery, error) {
	iter, err := wal.NewLogIter(logFile, logSer)
	if err != nil {
		return nil, err
	}

	return &Recovery{
		logs:       iter,
		logManager: wal.NewLogManager(logFile),
		dm:         dm,
	}, nil
}

// Recover is called to come back from failures. Brings database file to its latest correct state.
func (r *Recovery) Recover() error {
	if err := wal.PrevToType(r.logs, wal.TypeCheckpointEnd); err != nil {
		return err
	}

	if err := wal.PrevToType(r.logs, wal.TypeCheckpointBegin); err != nil {
		return err
	}

	// TODO: Somehow get active txn from checkpoint begin
	activeTxn := make(map[transaction.TxnID]bool)

	// redo all logs until log end and populate active txn map
	for {
		lr, err := r.logs.Next()
		if err != nil {
			return err
		}
		if lr == nil {
			break
		}

		txn := lr.GetTxnID()
		if lr.Type() == wal.TypeCommit {
			delete(activeTxn, txn)
		} else {
			activeTxn[txn] = true
		}

		if err := r.Redo(lr); err != nil {
			return err
		}
	}

	// Abort all active transactions that are running when crash occurred.
	// This essentially will undo all logs generated by these transactions.
	for id := range activeTxn {
		r.RollbackTxn(id)
	}

	return nil
}

// RollbackTxn rolls back all the changes reflected by transaction's log records.
func (r *Recovery) RollbackTxn(id transaction.TxnID) {
	// 1. create an iterator on logs that will iterate a transaction's logs in reverse order
	// 2. create clr logs that are basically logical negations of corresponding logs
	// 3. apply clr records and append them to wal
	// 4. append abort log

	logs := wal.NewTxnLogIterator(id, r.logs)
	for {
		lr, err := logs.Prev()
		if err != nil {
			if errors.Is(err, wal.ErrIteratorAtBeginning) {
				break
			}
		}

		if lr == nil {
			// if logs are finished it is rolled back
			break
		}

		if err := r.Undo(lr); err != nil {
			panic(err)
		}
	}

	r.logManager.AppendLog(wal.NewAbortLogRecord(id))
}

// Redo applies change in the log record if page's pageLsn is smaller than log's lsn, if not, this is a noop since
// changes are already on the page.
func (r *Recovery) Redo(lr *wal.LogRecord) error {
	p, err := r.dm.GetPage(lr.PageID)
	if err != nil {
		return err
	}

	if p.GetPageLSN() >= lr.Lsn {
		return nil
	}

	switch lr.Type() {
	case wal.TypeInsert:
		if err := p.InsertAt(int(lr.Idx), lr.Payload); err != nil {
			return err
		}
	case wal.TypeDelete:
		// TODO: validate if deleted is the same
		if err := p.DeleteAt(int(lr.Idx)); err != nil {
			return err
		}
	case wal.TypeSet:
		if err := p.SetAt(int(lr.Idx), lr.Payload); err != nil {
			return err
		}
	case wal.TypeFreePage:
		ok, err := r.dm.IsInFreeList(lr.PageID)
		if err != nil {
			return err
		}

		if !ok {
			r.dm.FreePage(lr.PageID)
		}
	case wal.TypeNewPage:
		ok, err := r.dm.IsInFreeList(lr.PageID)
		if err != nil {
			return err
		}

		if !ok {
			if err := r.dm.RemoveFromFreelist(lr.PageID); err != nil {
				return err
			}
		}
	default:
		panic("implement me")
	}

	return nil
}

// Undo creates a clr entry for given log and undoes it.
func (r *Recovery) Undo(lr *wal.LogRecord) error {
	// 1. create clr
	// 2. append clr to wal
	// 3. fetch page from buffer pool and cast it to slotted page
	// 4. undo action taken by log
	// TODO: when rolling back free page if a page with different id is created, btree nodes may point to the old page id
	p, err := r.dm.GetPage(lr.PageID)
	if err != nil {
		return err
	}

	if p.GetPageLSN() < lr.Lsn {
		return nil
	}

	clr, err := lr.Clr()
	if err != nil {
		return err
	}

	r.logManager.AppendLog(clr) // TODO: should we wait for flush?

	switch lr.Type() {
	case wal.TypeDelete:
		common.PanicIfErr(p.InsertAt(int(lr.Idx), lr.OldPayload))
	case wal.TypeSet:
		d := p.GetAt(int(lr.Idx))
		if bytes.Compare(d, lr.Payload) != 0 {
			panic("payload is different than logged")
		}
		common.PanicIfErr(p.SetAt(int(lr.Idx), lr.OldPayload))
	case wal.TypeInsert:
		d := p.GetAt(int(lr.Idx))
		if bytes.Compare(d, lr.Payload) != 0 {
			panic("payload is different than logged")
		}
		common.PanicIfErr(p.DeleteAt(int(lr.Idx)))
	default:
		panic("implement me")
	}

	return nil
}
